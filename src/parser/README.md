# bsc::parser

## Purpose

bsc::parser is a C++20 commandline argument parsing utility. It's a wrapper around GNU argp. 

### Design goals

There are many commandline parsing utilities, why should you choose this one? This one has:

* **Ease of use** - declare one structure and it will be filled with data from arguments. No need to use callback and define parsers for specific arguments - everything will be parsed according to field type and stored in it. 
* **Type safety** - every argument has a specific type and it uses simple string parser to convert user entered data to that type. Data are stored in C++ struct and user does not have to guess string keys for map, that some other tools return. 
* **Modern C++ features** - this library uses designated initializers as an easy way to configure expected commandline arguments and concepts to parse them correctly. 


### Usage

First, you have to define a structure that will hold the parsed arguments. It has to inherit from bsc::CommandLineParameters class and define one or more fields which define and will store parsed arguments. 

All parameters could be defined by setting up fields :
* shortKey - single letter parameter key eg. -a
* longKey - single word parameter key, eg. --option
* doc - documentation text describing the option
* argumentName - the name of the option argument, if not provided then parameter does not take an argument
* defaultValue - default value for the parameter if parameter is not found in commandline options

You have to provide shortKey, longKey or both, but at least one of them has to be present. 

**Parameter<>** field hold optional value of the chosen type

**DefaultParameter<>** always hold an actual value, from the commandline, set from definition or default constructed

**Argument** is required commandline argument that have to follow the options

**Flag** is an alias for Parameter\<bool\>

There are some fields used to control how help is printed

**Group** can be used to split many options 

**Alias** can be used to define alternative keys for previous parameter

**Doc** can  be used to provide additional documentation

**Usage** can be used to provide alternative usage lines (default is autogenerated from provided options)

This structure will inherit those methods from CommandLineParameters :

* ```arguments()``` - returns all arguments (just the arguments, parameters are ommited)
* ```remainingArguments()``` - just like ```arguments()```, but returns only arguments that were not bound to Argument<> fields. 
* ```commandName()``` - returns parsed command name (usually argv[0])

```cpp
#include <parser/parameters/CommandLineParameters.h>

struct HelloWorldParameters : CommandLineParameters {
    //simple boolean flag
    Flag flag                    = {{.shortKey = 'f', .longKey = "flag", .doc = "Flag"}};
    //define parameter -i/--number which has int type and default value of 5
    DefaultParameter<int> number = {{.shortKey = 'i', .longKey = "number", .argumentName = "INT", .doc = "An integer number", .defaultValue = 5}};
    //define parameter -F/--float which has type float 
    Parameter<float> realNumber = {{.shortKey = 'F', .longKey = "float", .argumentName="FLOAT", .doc = "A floating point number"}};
    //start new group 
    Group g                     = {"Path group:"};
    //define parameter --map which has type of map from short to path 
    DefaultParameter<std::map<short, std::filesystem::path>> numbersToPathsMap = {{.longKey = "map", .argumentName="MAP", .doc = "Numbers to path map"}};
    //define that first required argument is of type string
    Argument<std::string> stringArgument;
    //define that second required argument is of type int
    Argument<int> intArgument;
};

int main(int argc, char* argv[]) {
    const auto& params = CommandLineParser::defaultParse<HelloWorldParameters>(argc, argv);
    
        if (params.flag()) {
            std::cout << "Flag is set" << std::endl;
        }
    
        std::cout << "Number is " << std::to_string(params.number()) << std::endl;
        if (params.realNumber()) {
            std::cout << "Real number was set and it is: " << std::to_string(*params.realNumber()) << std::endl;
        } else {
            std::cout << "Real number was not set" << std::endl;
        }
    
        std::cout << "Path map:  "<< std::endl;
        for (const auto& [key, value] : params.numbersToPathsMap()) {
            std::cout << std::to_string(key) << "=[" << value.string() << "]"<< std::endl;
        }
    
        std::cout << "Required argument 1 (string): " << params.stringArgument() << std::endl
                  << "Required argument 2 (int): " << params.intArgument() << std::endl;
    return 0;
}
```

Example runs:

```
./hello-world --help
Usage: hello-world [OPTION...] ARG#1 ARG#2

  -f, --flag                 Flag
  -F, --float=FLOAT          A floating point number
  -i, --number=INT           An integer number

 Path group:
      --map=MAP              Numbers to path map

  -?, --help                 Give this help list
      --usage                Give a short usage message

Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.

Process finished with exit code 0

```

```
./hello-world -f -i 1 --float=1.5 --map 1=/tmp,2=/root text 5
Flag is set
Number is 1
Real number was set and it is: 1.500000
Path map:  
1=[/tmp]
2=[/root]
Required argument 1 (string): text
Required argument 2 (int): 5
```

```
./hello-world x 1
Number is 5
Real number was not set
Path map:  
Required argument 1 (string): x
Required argument 2 (int): 1
```

## Other tools

bsc::parser includes two other useful tools. 
### fromString parser

Simple string parser, Parser::fromString() that is used to convert text to types. If type is convertible to string (has string constructor), then then return value is built this way. For numbers functions like std::stoi, std::stof (adequate for specified type) are used. comma separated values are parsed as containers, pairs are parsed from key=value expression, and maps are treated as a container of pairs. Delimiters are configurable in Parser constructor.
Examples:

|type|value|
|---|---|
|int|5|
|float|5.5|
|string|text|
|std::vector<int>|1,2,3,4|
|std::list\<std::string>|text 1, text 2, text 3|
|std::pair<int,float>|5=1.2|
|std::map<int,int>|1=2,3=6|

### templateCast 
This small tool allows to call any Callable object (function, function pointer, lambda, functor, pointer-to-member,etc.) with vector of strings containing values of its arguments. Values are converted to parameter types using fromString parser. 

## Dependencies

The only dependency of this project is GNU argp, which is included as part of GNU standard library (GLIBC). If you are using GCC with standard libraries, this project should work without any additional dependencies. If you are using clang or not using standard libraries from GNU, you should install and link against standalone GNU argp. 