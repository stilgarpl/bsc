# bsc::parser

## Purpose

bsc::parser is a C++20 commandline argument parsing utility. It's a wrapper around GNU argp. 

### Design goals

There are many commandline parsing utilities, why should you choose this one? This one has:

* **Ease of use** - declare one structure and it will be filled with data from arguments. No need to use callback and define parsers for specific arguments - everything will be parsed according to field type and stored in it. 
* **Type safety** - every argument has a specific type and it uses simple string parser to convert user entered data to that type. Data are stored in C++ struct and user does not have to guess string keys for map, that some other tools return. 
* **Modern C++ features** - this library uses designated initializers as an easy way to configure expected commandline arguments and concepts to parse them correctly. 


### Usage

First, you have to define a structure that will hold the parsed arguments. It has to inherit from bsc::CommandLineParameters class and define one or more fields which define and will store parsed arguments. 

All parameters could be defined by setting up fields :
* shortKey - single letter parameter key eg. -a
* longKey - single word parameter key, eg. --option
* doc - documentation text describing the option
* argumentName - the name of the option argument, if not provided then parameter does not take an argument
* defaultValue - default value for the parameter if parameter is not found in commandline options


**Parameter<>** field hold optional value of the chosen type

**DefaultParamter<>** always hold an actual value, from the commandline, set from definition or default constructed

**Argument** is required commandline argument that have to follow the options

**Flag** is an alias for Parameter\<bool\>

There are some fields used to control how help is printed

**Group** can be used to split many options 
**Alias** can be used to define alternative keys for previous parameter
**Doc** can  be used to provide additional documentation
**Usage** can be used to provide alternative usage lines (default is autogenerated from provided options)

```
struct HelloWorldParameters : CommandLineParameters {
    Flag flag                    = {{.shortKey = 'f', .longKey = "flag", .doc = "Flag"}};
    DefaultParameter<int> number = {{.shortKey = 'i', .longKey = "number", .argumentName = "INT", .doc = "An integer number", .defaultValue = 5}};
    Parameter<float> realNumber = {{.shortKey = 'F', .longKey = "float", .argumentName="FLOAT", .doc = "A floating point number"}};
    Group g                     = {"Path group:"};
    DefaultParameter<std::map<short, std::filesystem::path>> numbersToPathsMap = {{.longKey = "map", .argumentName="MAP", .doc = "Numbers to path map"}};
    Argument<std::string> stringArgument;
    Argument<int> intArgument;
};

int main(int argc, char* argv[]) {
    const auto& params = CommandLineParser::defaultParse<HelloWorldParameters>(argc, argv);
    
        if (params.flag()) {
            std::cout << "Flag is set" << std::endl;
        }
    
        std::cout << "Number is " << std::to_string(params.number()) << std::endl;
        if (params.realNumber()) {
            std::cout << "Real number was set and it is: " << std::to_string(*params.realNumber()) << std::endl;
        } else {
            std::cout << "Real number was not set" << std::endl;
        }
    
        std::cout << "Path map:  "<< std::endl;
        for (const auto& [key, value] : params.numbersToPathsMap()) {
            std::cout << std::to_string(key) << "=[" << value.string() << "]"<< std::endl;
        }
    
        std::cout << "Required argument 1 (string): " << params.stringArgument() << std::endl
                  << "Required argument 2 (int): " << params.intArgument() << std::endl;

}
```

Example runs:

```
./hello-world --help
Usage: hello-world [OPTION...] ARG#1 ARG#2

  -f, --flag                 Flag
  -F, --float=FLOAT          A floating point number
  -i, --number=INT           An integer number

 Path group:
      --map=MAP              Numbers to path map

  -?, --help                 Give this help list
      --usage                Give a short usage message

Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.

Process finished with exit code 0

```

```
./hello-world -f -i 1 --float=1.5 --map 1=/tmp,2=/root text 5
Flag is set
Number is 1
Real number was set and it is: 1.500000
Path map:  
1=[/tmp]
2=[/root]
Required argument 1 (string): text
Required argument 2 (int): 5
```

```
./hello-world x 1
Number is 5
Real number was not set
Path map:  
Required argument 1 (string): x
Required argument 2 (int): 1
```