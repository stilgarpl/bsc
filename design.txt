w Node moze byc lista modułów
Node przetwarza moduły, które robią co uważają, rozszerzając w ten sposób możliwości Node, który sam z siebie tylko zarządza siecią

JournalModule
FilesystemModule
or sth


kazdy moduł miałby setupLogic które ustawiałoby logikę


jak logicznie polaczyc PacketGroup z eventami?

request -> event -> response... gdzie przetrzymac connection?
event jest procesowany w innym wątku! nie mozna utrzymać kontekstu między pakietem a eventem... chyba, ze go bezpośrednio przekażemy

w process jest ConnectionContext.


setupOriginFromContext<OriginType>::setupOrigin(OriginType& origin)


Dependencies module

class Dupa {

IDependency* after = new Dependency<Dupa1,Dupa2,Dupa3>();
Dependency<Dupa4,Dupa5> before;

}

Dependency przerabia liste klas na liste intow mechanizmem z ubera. z kazdej klasy mozna pobrac jej id

node uruchamiajac klasy moze je sobie posortowac odpowiednio
dependency sorting


Command module with module submodules and mapping

commandModule->map<BasicModule>("start", BasicModule::startNode);

command by parsował parametry z main i wysylal command packet do wlasciwej instancji node.


command powinien procesowac argumenty wejsciowe i stdin! zeby mozna bylo napisac skrypty

w trybie remote control kazde polecenie powinno generowac command packet
w trybie local polecenia maja byc wykonane na obecnym node

moze byc niby-shell, gdzie do persystowania plikow mozna chodzic po drzewie katalogow

Command source -> command event(module, command, v<data>) -> commandmodule->run(module,cmd,data);


CommandModule should have dynamic dependency
addDependency<Module> z mappingu


z Commnad wywalic "module", zamiast tego zrobic drzewiasty subcommanddispatcher

cmd->mapCommand("opengl", &CommandModule::subCommandDispatcher) <- a ile parametrow bedzie mial subcommand dispatche???????

inne rozwiazanie, zachowac module, ale dodac "using module persistence" np

zeby mozna bylo w shellu uzywac
cd DIR

persist file.file

define submodule -> wersja z subCommandDispatcher jest nierealna, bo nie wiadomo ile argumentow przyjdzie, a tu musialby byc alternatywny flow ktory przekazuje caly vector

cmd->submodule("opengl")->mapCommand("set", &OpenGlModule::set);
cmd->mapComannd == cmd->DefaultSubModule()->mapCommand

pierwszy argument byłby sprawdzany czy jest w submodule. jesli jest, no to submodule(arg[0])->runCommand(arg[1], args...)
jesli nie, noto submodule()->runCommand(arg[0], args...)

a runCommand w submodule mogloby robic to samo, wiec mozliwe byloby

cmd->submodule("remote")->submodule("opengl")->mapCommand


Args... -> std::string, argsid - to umozliwiloby przeciazanie roznymi parametrami tej samej metody...
na pewno trywialnie mozna zrobic liczbe argumentow, a typy... typy chyba nie, bo jak rozpoznac, co user wpisal.
@todo THAT ^^^^

