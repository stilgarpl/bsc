Start aplikacji:

Załadować ustawienia node, uruchomić node na dostępnym porcie.

Załadować listę sieci/nodów. Spróbować połączyć się z nodami.

Z połączonych nodów, pobrać informacje o nich i ich stanie.



procesowanie pakietow:

odebrane pakiety idą na kolejkę w connectionie.
connectionProcessor odbiera te pakiety z kolejki i odpala im ->process(context)
procesowanie np. getNodeInfo powinno uzupełnić node info, co z kolei powinno zatriggerowac wszystkie future oczekujace na to

bo np. jest jakiś wątek

{
do stuff...
node->getNodeInfo(..., [&](){and then do this};
do other stuff...
}


logika na zasadzie

source => trigger => action => result

np.

clock => @17:30 => discover_nodes => network_list updated

sync_manager => new_file => update_journal
sync_manager => journal_updated => push_info_to_other_nodes


sources manager podobny do Context - mapa<ISource>, ale jednoczesnie mozna zrobic get<Clock>, zeby wziac konkretny source

actions... jak by tu zrobic akcje

bo dalem w triggerze mozliwosc odpalenia jakiejkolwiek funkcji...

sourceManager.registerTrigger<Tick>(actionManager.getAction<Tick>("tock");
sm.registerTrigger<NetEvent>(am.getAction<NetEvent>(

logic.assignAction<EVENT>([optional: event id,]action id);

logic.aA<NetEvent,NetAction>(NetEvent::IdType::NODE_DISCOVERED,NetAction::IdType::SAVE_NODE_INFO);
logic.aA<Tick,NetAction>(150s, "sendKeepAlive");








ok, no to teraz pisze moj pierwszy istotny source, network source
jak go zintegrować z warstwą protokołu?

implementacja protokołu jest rozproszona na pakiety i spięta procesorem
procesor móglby wszystkie pakiety przekazywać do net source, ale skad net source ma wiedziec co to, wirtualnych nie bedzie przeciez obslugiwac

w tym momencie najbardziej widze to jako Observer:
protokół w momencie wystąpienia istotnych momentów, np. connection establshed, node info received itd. robiłby notify do wszystkich zainteresowanych
a tym byłby właśnie net source. net source pchałby to dalej



blah, wlasnie zrobilem durnowata zmiane, bez przemyslenia.
wprowadzilem globalny kontekst w Node, mimo, ze juz wczesniej to rozwiazalem również durnym sposobem na IContextSetup::setup

mysle, zeby mozna bylo zostawic nowy sposób, konteksty ConnectionContext i NodeContext moznaby zostawic nawet w postaci czystych struktur
a jak zapewniac kontekst polaczenia? dla ConnectionContext moznaby robic identyfikator identyfikujacy polaczenie - kazde polaczenie mialoby swoj connectioncontext.

brzydkie, wiem

idea: hierarchiczny context: każdy poziom ma swój kontekst, node, connection etc. i context jak ma nulla u siebie to patrzy czy poziom wyzej cos jest
idea2: sumowanei kontekstow

w connection Context context += nodeContext; <- w tym przypadku kazdy ma swoj wlasny kontekst, nie ma problemow z thread safety ale za to zmiany w nodecontext nie propaguja sie nizej.


network packet id - autogenerowane kolejne liczby
zapamietujemy ktore requesty wyszly z jakimi liczbami
i na ktore dostalismy response
jesli nie dostalismy response, mozna resendnac packet




request => future promise => fullfill

protocol: transactions
transaction id
transaction has flow composed of packets


protocol->startTransaction(transaction) -> future<transactionresult>

transaction:

send CommandPacket::REQUEST
receive CommandPacket::RESPONSE -> run thisTransaction->nextPhase?
send OtherPacket::REQUEST
receive OtherPacket::RESPONSE


protocol->send(Packet, [&](receivedPacket){ do sth and then protocol->send(otherPacket,[&](receivedPacket2){do something else;});})


~ : public BasePacket
<~>
Result<~> send(PacketPtr<~>);

<~>
Result {
future<~> f
std::function<> and_then;
}

<~>
void send(PacketPtr<~>, std::function<Context&>) {
Result r = send(...);
std::thread t([](r){result.f.get(); result.and_then()};
t.detach();
}




ALBO LEPIEJ

niech send zwraca future result

transakcja to wątek
sendX, wait, do stuff, sendY, wait, do stuff

a moze by zdefiniowac sobie traitsy?

BasePacket::ResponseTo<CommandPacket>::type => CommandResponsePacket
albo wykorzystac wirtuale i niech process robi co trzeba...

przykladowy flow:

runTrans() {

response = send<NodeInfoResponse>(Request for NodeInfo)
response.wait() // the actual action will take place in response->process(); which will probably do nothing but request->process() will be the one which prepares the actual answer









jak zrobic, zeby Graviton wiedzial, jaki jest typ odpowiedzi dla send() ?
mozna zrobic np. tak:

<T>
PacketInfo<PacketInfo<T>::BaseType,Status::Response>::Type send(T)

T : public packet<BaseT,Status::Request> <-- packet w jakis sposob by rejestrowal powiazanie T, BaseT i Status w PacketInfo

